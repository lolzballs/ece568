#Benjamin Cheng, 1004838045, benjamin.cheng@mail.utoronto.ca

target1:
The strcpy in foo() will buffer overflow `buf` if given argv[1] with >272 chars.
To exploit this, the location of the return address of lab_main() relative to the
beginning of `buf` was found to be 0x158. A shellcode is placed at the start of
`buf`, which is then followed with arbitrary padding bytes until the 0x158-th
element, where the address of `buf` is placed. This address was found to be
0x40A4FD70 on ECF lab computers, but on other systems a lower address was found.
Thus NOP bytes were added to the beginning of `buf` to make the exploit more
portable.

target2:
foo() copies the input string to buf, but can overflow by 20 bytes. We cannot
directly modify the return address since it is located at 36 bytes past the end
of buf. len resides at 16 to 20 bytes past the end of buf. Thus we can
arbitarily set len using our attack buffer to increase the iterations of the
loop. j is also located on the stack, so we set j to 0x127 to reach the return
address. This attack buffer contains NULL bytes, which are dealt with by passing
input following the NULLs in new strings in envp.

target3:
bar() copies the a maximum of 103 bytes from user-supplied input to &targ[12].
Since buf/targ only has 67 bytes, there is an overflow of 48 bytes. buf is in
the stack frame of foo(), so we target the return address in that function
instead, which is at &buf[88]. This is within our overflow-able range so it is
straight forward to override the return address with &buf, where the shellcode
is located.
